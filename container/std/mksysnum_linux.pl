#!/usr/bin/env perl
# Copyright 2009 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

use strict;
use POSIX ();

my $command = "mksysnum_linux.pl ". join(' ', @ARGV);
my $uname_arch = (POSIX::uname)[4];
my %syscall_cutoff_arch = (
	"x86" => 340,
	"x86_64" => 302,
	"aarch64" => 281,
);

print <<EOF;
// $command
// Code generated by the command above; DO NOT EDIT.

package std

import . "syscall"

var syscallNum = map[string]ScmpSyscall{
EOF

my $offset = 0;
my $state = -1;

sub fmt {
	my ($name, $num) = @_;
	if($num > 999){
		# ignore deprecated syscalls that are no longer implemented
		# https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/asm-generic/unistd.h?id=refs/heads/master#n716
		return;
	}
	(my $name_upper = $name) =~ y/a-z/A-Z/;
	$num = $num + $offset;
	if($num > $syscall_cutoff_arch{$uname_arch} && $state == 0){ # not wired in Go standard library
		print " SYS_$name_upper = $num\n";
	}
	elsif($state == -1){
		print "	\"$name\": SNR_$name_upper,\n";
	}
	elsif($state == 1){
		print " SNR_$name_upper ScmpSyscall = SYS_$name_upper\n";
	}
	else{
		return;
	}
}

GENERATE:

my $prev;
open(GCC, "gcc -E -dD $ARGV[0] |") || die "can't run gcc";
while(<GCC>){
	if(/^#define __NR_Linux\s+([0-9]+)/){
		# mips/mips64: extract offset
		$offset = $1;
	}
	elsif(/^#define __NR_syscalls\s+/) {
		# ignore redefinitions of __NR_syscalls
	}
	elsif(/^#define __NR_(\w+)\s+([0-9]+)/){
		$prev = $2;
		fmt($1, $2);
	}
	elsif(/^#define __NR3264_(\w+)\s+([0-9]+)/){
		$prev = $2;
		fmt($1, $2);
	}
	elsif(/^#define __NR_(\w+)\s+\(\w+\+\s*([0-9]+)\)/){
		fmt($1, $prev+$2)
	}
	elsif(/^#define __NR_(\w+)\s+\(__NR_Linux \+ ([0-9]+)/){
		fmt($1, $2);
	}
}

if($state == -1){
	print "}\n\nconst (\n";
}
elsif($state == 0){
	print ")\n\nconst (\n";
}
elsif($state == 1){
	print ")";
	exit;
}
++$state;
goto GENERATE;

